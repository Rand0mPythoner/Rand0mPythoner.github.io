---
layout: post
title: "前端加密算法记录.1"
subtitle: "前端加密算法记录.1"
author: "Novocaine#p1an0@qq.com"
header-img: "img/post-bg-dreamer.jpg"
header-mask: 0.4
tags:
  - JAVASCRIPT
  - 加密
---

> 最近前端加密又火起来了，各式各样的前端加密挺烦的，有些加密的作者很贴心的给了解密函数，其实只要贴上解密函数就好了
>
> 本篇笔者着重讲一下怎么寻找加密函数/解密函数

0x01 干这事的目的
=========
1. 需要绕过前端过滤器，伪造数据包。
2. 在测试过程中发现关键变量，但是写死无法修改
3. 有开发怼你

0x02 关键字查找:
========

这个就不多说了，我个人搜索常见的关键字有：

> encrypt,decrypt,SM4,RC4,AES,MD5,SIGN

使用正则效果更佳

找到关键位置直接下断调试就可以了，细心跟踪关键变量，很轻松的就可以实现伪造数据包发包了

0x03 接口方式查找:
========
现在POST请求一般都是接口形的了，开发往往也把接口地址放到ajax里面，所以我们只需要找接口地址就能找到对应的AJAX，再根据参数查找调用栈就能找到了

注意比较复杂的是头里的参数中带着加密，接口的方式往往比较难找，笔者至今还没想到有什么方式可以找到

0x03 find_element_by_*
==
selenium浏览器类提供了搜索元素的函数，总的来说还是比bs4简洁许多，门槛低了很多，直接调用方法就可以返回一个元素对象
```
 def find_element_by_id(self, id_):
        
        return self.find_element(by=By.ID, value=id_)

    def find_elements_by_id(self, id_):
        
        return self.find_elements(by=By.ID, value=id_)

    def find_element_by_xpath(self, xpath):
        
        return self.find_element(by=By.XPATH, value=xpath)

    def find_elements_by_xpath(self, xpath):
        
        return self.find_elements(by=By.XPATH, value=xpath)

    def find_element_by_link_text(self, link_text):
        
        return self.find_element(by=By.LINK_TEXT, value=link_text)

    def find_elements_by_link_text(self, text):
        
        return self.find_elements(by=By.LINK_TEXT, value=text)

    def find_element_by_partial_link_text(self, link_text):
        
        return self.find_element(by=By.PARTIAL_LINK_TEXT, value=link_text)

    def find_elements_by_partial_link_text(self, link_text):
        
        return self.find_elements(by=By.PARTIAL_LINK_TEXT, value=link_text)

    def find_element_by_name(self, name):
        
        return self.find_element(by=By.NAME, value=name)

    def find_elements_by_name(self, name):
        
        return self.find_elements(by=By.NAME, value=name)

    def find_element_by_tag_name(self, name):
        
        return self.find_element(by=By.TAG_NAME, value=name)

    def find_elements_by_tag_name(self, name):
        
        return self.find_elements(by=By.TAG_NAME, value=name)

    def find_element_by_class_name(self, name):
        
        return self.find_element(by=By.CLASS_NAME, value=name)

    def find_elements_by_class_name(self, name):
        
        return self.find_elements(by=By.CLASS_NAME, value=name)

    def find_element_by_css_selector(self, css_selector):
        
        return self.find_element(by=By.CSS_SELECTOR, value=css_selector)

    def find_elements_by_css_selector(self, css_selector):
        
        return self.find_elements(by=By.CSS_SELECTOR, value=css_selector)
```
可以看出来全都调用了find_element和find_elements方法，跟进去学习一下：
```
 def find_element(self, by=By.ID, value=None):
        if self.w3c:
            if by == By.ID:
                by = By.CSS_SELECTOR
                value = '[id="%s"]' % value
            elif by == By.TAG_NAME:
                by = By.CSS_SELECTOR
            elif by == By.CLASS_NAME:
                by = By.CSS_SELECTOR
                value = ".%s" % value
            elif by == By.NAME:
                by = By.CSS_SELECTOR
                value = '[name="%s"]' % value
        return self.execute(Command.FIND_ELEMENT, {
            'using': by,
            'value': value})['value']
```
我把注释去了，因为没啥可解释的，就是一堆if，execute这个函数是一个动态调用，call到command.FIND_ELEMENT，然后传入了一个字典，最后取value  
进入FIND_ENELMENT瞅瞅。  
``` Python
FIND_ELEMENT = "findElement"
	Command.FIND_ELEMENT: ('POST', '/session/$sessionId/element')
```
发现是个API，看来是我猜错了，还是要看一下execute函数
```
def execute(self, command, params):
    command_info = self._commands[command]
    assert command_info is not None, 'Unrecognised command %s' % command
    path = string.Template(command_info[1]).substitute(params)
    if hasattr(self, 'w3c') and self.w3c and isinstance(params, dict) and 'sessionId' in params:
        del params['sessionId']
    data = utils.dump_json(params)
    url = '%s%s' % (self._url, path)
    return self._request(command_info[0], url, body=data)
```
最后发现还是调用了_request方法，data就是  
```
{'using': by,'value': value}
```
原理就分析到这里了，下一章会用一个爬虫来演示selenium怎么使用。