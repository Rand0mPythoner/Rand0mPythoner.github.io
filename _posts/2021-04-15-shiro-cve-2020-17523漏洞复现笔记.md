---
layout: post
title: "shiro-cve-2020-17523漏洞复现笔记"
subtitle: "WTF about shiro-cve-2020-17523"
author: "Rand0m ^ Novocaine#p1an0@qq.com"
header-img: "img/post-bg-dreamer.jpg"
header-mask: 0.4
tags:
  - Java
  - Shiro
---

0x01 序
--
- 最近hvv太累了（根本没参加啊喂
- 休养生息了一段时间，一直在想后面该学什么完成什么。
- 找几个比较有用的简单的漏洞复现分析一下吧。
- 看完发现代码写的是真j8乱。

0x02 漏洞描述
--
 - Apache Shiro是个框架，通常用来做鉴权，你们渗透里看到的cookies:remberme=deleteme就是shiro很常见的标志。
 - Apache Shiro给开发者提供了完善的API，apache有完善的API文档：http://shiro.apache.org/static/1.2.3/apidocs/
 - 当Shrio与Spring结合，在一定规则匹配下，攻击者才可以构造特殊http请求进行身份权限绕过。

0x03 环境搭建
--

shiro 1.7.0

https://github.com/jweny/shiro-cve-2020-17523 两种姿势的漏洞环境均已更新。

0x04 POC:
--
原文作者给出的POC：
两个姿势：
	http://127.0.0.1:8080/admin/%20 或 http://127.0.0.1:8080/admin/%20/
	http://127.0.0.1:8080/admin/%2e 或 http://127.0.0.1:8080/admin/%2e/
第二种如果开启全路径（setAlwaysUseFullPath(true)）是可以成功的，但是失败也不会触发鉴权失败的规则，而是跳转到404。
```java
setAlwaysUseFullPath in SpringbootShiroApplication.java line:34
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName)
            throws BeansException {
        if (bean instanceof RequestMappingHandlerMapping) {
            ((RequestMappingHandlerMapping) bean).setAlwaysUseFullPath(true);
        }
        return bean;
    }
```

0x05 喜闻乐见的代码diff环节
--
commit id为：e61a29cd6ad4724cf9d85c463103c01f6bafdc44

对比一下新老代码：
```java
//老代码：
public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) {
        FilterChainManager filterChainManager = getFilterChainManager();
        if (!filterChainManager.hasChains()) {
            return null;
        }

        String requestURI = getPathWithinApplication(request);

        // in spring web, the requestURI "/resource/menus" ---- "resource/menus/" bose can access the resource
        // but the pathPattern match "/resource/menus" can not match "resource/menus/"
        // user can use requestURI + "/" to simply bypassed chain filter, to bypassed shiro protect
        if(requestURI != null && !DEFAULT_PATH_SEPARATOR.equals(requestURI)
                && requestURI.endsWith(DEFAULT_PATH_SEPARATOR)) {
            requestURI = requestURI.substring(0, requestURI.length() - 1);
        }


        //the 'chain names' in this implementation are actually path patterns defined by the user.  We just use them
        //as the chain name for the FilterChainManager's requirements
        for (String pathPattern : filterChainManager.getChainNames()) {
            if (pathPattern != null && !DEFAULT_PATH_SEPARATOR.equals(pathPattern)
                    && pathPattern.endsWith(DEFAULT_PATH_SEPARATOR)) {
                pathPattern = pathPattern.substring(0, pathPattern.length() - 1);
            }

            // If the path does match, then pass on to the subclass implementation for specific checks:
            if (pathMatches(pathPattern, requestURI)) {
                if (log.isTraceEnabled()) {
                    log.trace("Matched path pattern [" + pathPattern + "] for requestURI [" + Encode.forHtml(requestURI) + "].  " +
                            "Utilizing corresponding filter chain...");
                }
                return filterChainManager.proxy(originalChain, pathPattern);
            }
        }

        return null;
    }
```

```java
//新代码
//不放了奥，自己去看，新电脑没法截图看不到行数兄弟们。
```
看到两个if逻辑去掉了同一个判断（!DEFAULT_PATH_SEPARATOR.equals(xxx)）

再往下看发现改了PathMatchingFilter.java 
看看diff

```java
    protected boolean pathsMatch(String path, ServletRequest request) {
        String requestURI = getPathWithinApplication(request);
        if (requestURI != null && !DEFAULT_PATH_SEPARATOR.equals(requestURI)
                && requestURI.endsWith(DEFAULT_PATH_SEPARATOR)) {
            requestURI = requestURI.substring(0, requestURI.length() - 1);
        }
        if (path != null && !DEFAULT_PATH_SEPARATOR.equals(path)
                && path.endsWith(DEFAULT_PATH_SEPARATOR)) {
            path = path.substring(0, path.length() - 1);
        }
        log.trace("Attempting to match pattern '{}' with current requestURI '{}'...", path, Encode.forHtml(requestURI));
        return pathsMatch(path, requestURI);
    }
```
**新的还是不放了奥，兄弟们勤快点看，新电脑没配图床。**
感觉和上面还是一样啊，判断传入的字符串等不等于DEFAULT_PATH_SEPARATOR判断逻辑给去掉了，分别调试的时候发现的确去掉这个逻辑之后进了处理了。

从diff分析看应该关键在于传入字符串的最后一位(%20或%2e)对match造成了影响，看看环境作者怎么写的match：

```java
map.put("/admin/*", "authc");
```

match在AntPathMatcher.java Line 108行：
太长了，谁爱读谁读，这洞从修复手法看出来应该还是要截取最后一位字符，至于空格和点为什么会影响shiro的domatchs我就不管了，挖这种洞我以后也靠fuzz了QAQ


0x03 参考文档
--
-  https://github.com/apache/shiro
-  https://github.com/jweny/shiro-cve-2020-17523
-  https://paper.seebug.org/1478/
